/*
假设一个数为 ： p 进制下的 a1a2a3 % B == 0,者以下俩个等式一定成立：
1）a1 * p ^ 2 + a2 * p ^ 1 + a3 * p ^ 1 = sum % B == 0,
2）a1 + a2 + a3 = ans % B == 0

以上两个式子同时成立的条件是 ： p % B == 1
所以满足条件的 B 的个数为 p - 1 的因子数

或

思路：

先理解一下为什么一个数各个数位上的和是3的倍数那这个数就是3倍数：
先看两位数字的,如数码ab组合
a+b为3的倍数
那么10*a+b=9a+(a+b)
9a能被3整除,a+b能被3整除,所以10+b能被3整除
再看三位数字的,如数码abc组合
a+b+c为3的倍数
那么100*a+10*b+c=99a+9b+(a+b+c)
99a,9b,(a+b+c)都能被3整除,所以100*a+10*b+c能被3整除
实际上,对于任何一个自然数a(1)a(2)a(3)a(4)....a(n)
如果a(1)+a(2)+a(3)+...+a(n)为3的倍数
那么
a(1)*10^(n-1)+a(2)*10^(n-2)+....+a(n-1)*10+a(n)
=a(1)*[10^(n-1)-1]+a(2)*[10^(n-2)-1]+...+a(n-1)*9+[a(1)+a(2)+...+a(n)]
中间的每一项.都能被3整除
所以：
一个数各个数位上的和是3的倍数那这个数就是3倍数

优化方法:

每个数至少两个因子，一个1，一个自己本身，
所以直接定义ans=2，然后从2到sqrt(n)，遍历，
找到可以除尽的就把ans+=2；
考虑一点，如果n本身是完全平方数,就要把ans---;
*/
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
typedef long long ll;
const int maxn = 1005;

int main() {
	int t; 	cin >> t;
	while(t--) {
		ll n;
		cin >> n;	n--;

		int ans = 0;
		for(ll i = 1; i * i <= n; i++) {
			if( n % i == 0) {
					ans++;
				if( i * i != n )
						ans++;
			}
		}
		cout << ans << endl;
	}
}